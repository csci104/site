
In this problem you will write your own hash function for `std::string` in the provided `hash.h` file.  While `std::string`s can be of arbitrary length and contain any legal ASCII character, we will assume the largest string you will ever receive is 28 letters long (e.g. `antidisestablishmentarianism`) and only contains letters and digits ('0'-'9').  For the letters, you should treat upper-case letters the same as you would lower-case letters.

#### The Approach

The basic approach will be to treat groups of letters/digits as base-36 and convert to an integer value (i.e. the decimal equivalent).

First translate each letter into a value between `0` and `35`, where `a=0`, `b=1`, `c=2`, ...., `z=25` and digit `'0'=26`, ... `'9'=35`.  Be sure to convert an upper case letter to lower case before performing this mapping. Next you will translate a (sub)string of 6 letters `a1 a2 a3 a4 a5 a6` into an (`unsigned long long`) 64-bit integer `w[i]` (essentially converting from **base-36** to decimal), via the following mathematical formula:


$$w[i] = 36^5*a1 + 36^4*a2 + 36^3*a3 + 36^2*a4 + 36*a5 + a6$$

Place zeros in the leading positions if your (sub)string is shorter than 6 letters. So `104` would set a1, a2, and a3 all to zero and yield $$36^2*27 + 36*26 + 30$$.  You should use the base conversion approach taught in class to avoid repeated calls to `pow()`.  Note that indexing is a bit tricky here so think carefully.  The digit at the "end" of the string is assigned the power 36^0, and the 2nd to last letter is worth 36^1, etc.  

If an input word is longer than 6 letters, then you should first do the above process for the **last** 6 letters in the word, then repeat the process for each previous group of 6 letters.  Recall, you will never receive a word longer than 28 characters.  The last group may not have 6 letters in which case you would treat it as a substring of less than 6 characters as described above.  Since we have at most 28 characters this process should result in a sequence of no more than 5 integers: w[0] w[1] w[2] w[3] w[4], where w[4] was produced by the last 6 letters of the word.

Store these values in an array (of `unsigned long long`). Place zeros in the leading positions of w[i] if the string does not contain enough characters to make use of those values. So for a string of 12 letters, w[0], w[1], and w[2] would all be 0 and only w[3] and w[4] would be (potentially) non-zero.

We will now hash the string. Use the following formula to produce and return the final hash result using the formula below (where the `r` values are explained below). 

$$h(k) = (r[0]*w[0] + r[1]*w[1] + r[2]*w[2] + r[3]*w[3] + r[4]*w[4])$$

where the $$r[i]$$ values are either:
 - 5 random numbers created when you instantiate the hash function using the current time as your seed (i.e. `srand(time(0))`). Be sure to `#include <ctime>` and `#include <cstdlib>`.
 - 5 preset values for debugging (so we all get the same hash results): `r[0]=983132572, r[1]=62337998, r[2]=552714139, r[3]=984953261, r[4]=261934300` (these numbers were generated by random.org)

Note: We will allow h(k) to produce a large integer (beyond the range of `m`, the table size) and only mod it by the table size in the hash table (see other programming problem).

The constructor of your hash object will take a `debug` parameter, which, if `true` should set the `r` values to the above debugging values, and if `false` should select the ranomized values.

Note:  Make sure you compute using `unsigned long long` variables or cast (constants or other variables) to that type at the appropriate places so that you don't have an overflow error. 

#### Testing

We have provided a simple test program, `str-hash-test.cpp` where you can provide a string on the command line and it will hash the string and output the hash result. Below is some debug output of the `w[i]` values computed for several test strings using the debug `r` values. 

Below is the output for a few strings:

`./str-hash-test abc`

yields 

```
w[0] = 0
w[1] = 0
w[2] = 0
w[3] = 0
w[4] = 38
h(abc)=9953503400
```

`./str-hash-test abc123`

yields

```
w[0] = 0
w[1] = 0
w[2] = 0
w[3] = 0
w[4] = 1808957
h(abc123)=473827885525100
```

`./str-hash-test-sol B`

yields

```
w[0] = 0
w[1] = 0
w[2] = 0
w[3] = 0
w[4] = 1
h(B)=261934300
```

`./str-hash-test-sol gfedcba`

yields

```
w[0] = 0
w[1] = 0
w[2] = 0
w[3] = 6
w[4] = 309191940
h(gfedcba)=80987980279261566
```


`./str-hash-test antidisestablishmentarianism`

yields

```
w[0] = 17540
w[1] = 195681115
w[2] = 2203855
w[3] = 732943745
w[4] = 484346964
h(antidisestablishmentarianism)=1137429692708383810
```


---
layout: asides
toc: true
tasks: true
title: Homework 6 Programming
---

# HW6: Programming Assignment

+ Due: Saturday, May 1st, 11:59pm PST

+ To access the written portion of this assignment, click [here](..)

+ Directory name in your github repository for this homework (case sensitive): `hw6`

  - There is no skeleton code for this assignment.
  - You **MUST** provide a `Makefile` so that we can compile your code (not run it) by simply typing `make`.
- Remember to compile and test your code inside Docker (but should do your git commands outside Docker)
  - Provide a `README.md` file to explain how to compile your code, and to document any oddities you want the graders to be aware of.
  

### Problem 0 (Course Evaluations, 0%)
Please make sure to fill out the online course evaluations for this course.  The instructor takes these seriously, and you can have a positive impact on how this class is taught in future semesters.  Pay it forward!

### Problem 1 (Create a hash table, 35%)

You will create a Hashtable<string,int> data structure with probing for collision resolution. We will use only strings made of lowercase letters, and no other characters. Your solution to this problem should be in files `Hashtable.h` and `Hashtable.cpp`. 

Your hash table will initially have 11 positions. You will need to implement the following functions:

+ `Hashtable (bool debug = false, unsigned int probing = 0)`: Constructor for the Hashtable. The effect of the Boolean `debug` flag is described below. The parameter `probing` will always be 0, 1, or 2. 0 means that your Hashtable must use linear probing, 1 means quadratic probing, and 2 means double hashing.
+ `~Hashtable ()`: Destructor
+ `add (string k)`: If k is already in the HashTable, then increment its value.  If it is new, add it to the HashTable with a value of 1.
+ `count (string k)`: Returns the int associated with k, or 0 if k is not in the Hashtable.
+ `reportAll (ostream &) const` : output, to the given stream, every (key,value) pair, in the order they appear in the hashtable;  on each line, output the key, followed by a space, followed by the value, and then a newline.
+ `resize ()`:  A private helper function which approximately doubles the number of indices available.  You call this function when you try to insert into a hash table whose load factor is already at least 0.5.  The number of indices should follow this sequence: 11, 23, 47, 97, 197, 397, 797, 1597, 3203, 6421, 12853, 25717, 51437, 102877, 205759, 411527, 823117, 1646237, 3292489, 6584983, 13169977, 26339969, 52679969, 105359969, 210719881, 421439783, 842879579, 1685759167. After resizing the table, you need to rehash all strings and their values, and you must rehash all of the strings starting from the beginning of the table and proceeding in order to the end of the table.
+ `int hash (string k) const`:  This private/protected function takes a string as input, and outputs a pseudo-random index to store it at. More detail on how to write this hash function is provided below.

When you create a HashTable or resize a HashTable without `debug` mode, you should generate 5 random numbers between 0 and m-1 (inclusive): we'll refer to them as r1, r2, r3, r4, r5.
When you create a debug-mode HashTable, you must set r1=983132572, r2=1468777056, r3=552714139, r4=984953261, r5=261934300 (these numbers were generated by `random.org`).

You will use the above 5 integers in your hash function detailed below.

#### Writing a Hash Function

First translate each letter into a value between 0 and 25, where a=0, b=1, c=2, ..., z=25.
You can translate a string of 6 letters a1 a2 a3 a4 a5 a6 into an int via the following mathematical formula:

`26^5 a1 + 26^4 a2 + 26^3 a3 + 26^2 a4 + 26 a5 + a6`

Place zeros in the leading positions if your word is shorter than 6 letters.  So `abc` would set a1, a2, and a3 all to zero.

If an input word is longer than 6 letters, then you should first do the above process for the last 6 letters in the word, then repeat the process for each successive 6 letters.  You will never receive a word longer than "antidisestablishmentarianism" (that is, 28 letters), which should result in a sequence of no more than 5 ints `w1 w2 w3 w4 w5`, where `w5` was produced by the last 6 letters of the word.

Store these values in an int array. Place zeros in the leading positions if the word was shorter than 25 letters.  So for a string of 12 letters, w1, w2, and w3 would all be 0.

We will now hash the word. Use the following formula to produce the result, and make sure to cast this into a `long long` at the appropriate places so that you don't have an overflow error: the compiler will assume each intermediate value is an int if you don't specify this.  `m` is the number of indices in the hashtable:

`(r1 w1 + r2 w2 + r3 w3 + r4 w4 + r5 w5) % m`

#### Creating Your Second Hash Function

You will need a second hash function for the double-hashing option.

`h(w) = p - ((w1+w2+w3+w4+w5) \% p)`

p must be a prime smaller than `size`. Use the following values for p. (The order corresponds to the table sizes we gave you above.)

7, 19, 43, 89, 193, 389, 787, 1583, 3191, 6397, 12841, 25703, 51431, 102871, 205721, 411503, 823051, 1646221, 3292463, 6584957, 13169963, 26339921, 52679927, 105359939, 210719881, 421439749, 842879563, 1685759113

### Problem 2 (Analyze the Hashtable, 15%)

Create a program `counting` that will be called as follows:

`./counting [input] [output] x d r`

Your submission should include a `counting.cpp` file which we will use to run your program. You should also include a rule in your `Makefile` to compile this problem with the command `make counting`.

+ `[input]` will be an input text file, which you will run your program on.
+ `[output]` will be an output text file, which you will store your results in.
+ x will be an integer with value 0, 1, 2, or 3.  If x=0, use linear probing.  If x=1, use quadratic probing.  If x=2, use double-hashing.  If x=3, use your AVL Tree from HW4 (if your AVL Tree isn't working, use the STL map, but that's much less interesting).
+ d will be an integer with value 0 or 1.  If d=0, then create a normal HashTable.  If d=1, then create a debug-mode HashTable.  This value is ignored by your program if x=3.
+ r will be an integer that says how often to repeat the whole program. (This is useful to measure the time when the input is small and the time is otherwise reported as 0.)

Your program should create a HashTable/AVL Tree, and populate it with the contents of the input text file.  Each word in the file will be separated by an arbitrary amount of whitespace (possibly including newlines and tabs).  For a given word, you should strip out all characters which are not the letters a-z or A-Z.  So the string "let's" should become "lets". Convert the string to all lowercase before storing it in your structure.

Your program should time how long it takes to insert/update all the words in the file. Since we want to focus on the time the Hashtable/AVL Tree takes, and not have it overshadowed by the time to access a file or parse inputs, you should first put the sequence of all pruned/stripped words into a `vector<string>`. Once you've done that, start the timer, and then record the time for inserting/updating all the words in the data structure. Repeat this r times, each time for a completely new instantiation of your data structure. Then stop/record the timer, and output the number of occurrences for all words in the text. 

We will guarantee the following for all input test cases we use on your program: 

+ You will never need more than 1685759167 indices.
+ All input words will be no longer than 28 letters.

#### Timing Your Code
To time your code, you can do something like the following:

```
#include <iostream>
#include <ctime>

int main() {
    clock_t start;
    double duration;

    /* Preprocessing here that you don't want to time */

    start = clock();

    /* Your algorithm here */

    duration = ( clock() - start ) / (double) CLOCKS_PER_SEC;

    std::cout << duration/r << endl;
}
```

For each input, run your program once each with linear probing, quadratic probing, double-hashing, and AVL Trees.  Make sure that your inputs cover several orders of magnitude, say, roughly 30, 300, 3000, and 30000 words (and larger, if you can find a good text for it). For a good large free text to use, you could use Shakespeare's Hamlet. If you can't find other shorter texts, you can always start from a longer text and only keep the first n words of it. For small texts, you'll need to use the r variable to get an accurate measurement.

#### What to Report

Answer the following questions in your readme file:

+ Which size of input cases did you use?
+ Did you use AVL Trees or the STL map?
+ For each of the 4 approaches (linear probing, quadratic probing, double hashing, AVL Trees), report how long each of your input cases took. How long did it take per operation?
+ Explain why you think the results turned out the way they did, and whether you were surprised by them.

### Finishing Up

### Completion Checklist

+ Directory name for this homework (case sensitive): `hw6`
  - This directory should be in your `hw-username` repository
  - This directory needs its own `README.md` file briefly describing your work
  - Any `.cpp` and `.h` files you created/migrated from hw4
  - Your `Makefile`
+ The submission link will be posted on Piazza a few days before the due date.
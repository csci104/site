---
layout: default
title: Final Info
nav: Resources
---

## Final Info

### Overview and Process

- Time/Date: **{{site.data.schedule.exams[1].time}}**
  - The test will be set for **2 hours.**
  - If you have USC approved accommodations, please confirm with me via email and we will make preparations for your approved time.  
- The test will be taken on Gradescope by logging into our Blackboard section, choose Assignmentments, and click on the Gradescope link. You will then find a **Final** assignment where you will be able to see the questions as simple HTML or download a PDF of the questions.  The skeleton files will be downloadable (linked) from the PDF and Gradescope page.  All answers need to be entered or uploaded to Gradescope, but you may use scratch paper to work out a problem. You can write your code in an editor and even try to compile and run if you like, but we are not expecting you do that and it will take away time from coding the other problems. While it might be useful to compile, we don't recommend running and debugging unless you have time.
- The exam is **Closed book, Closed notes, Closed Internet (search/reference)**. You may use your mind, an editor and/or compiler, and blank scratch paper but nothing else. No referencing your labs, homeworks, etc.
- You are allowed 1 **8.5x11 handwritten (front and back) cheatsheet**. No printed cheat sheets.  You will be asked to submit a picture of each side on Gradescope.

### Topics and Style

The midterm will include a mix of anlaysis and coding problems.  For anlaysis problems (tracing a recursive routine, describing a class hierarchy or appropriate ADTs), you can just type your answers into Gradescope.  For coding problems you must **upload** completed `.cpp` files.

#### Unit 11 - Tree and Graph Traversals
 - Breadth- and Depth-first search
 - In-, pre-, post-order tree traversals

#### Unit 12 - Backtracking Search
 - Recursion to generate all combinations
 - General backtracking code structure

#### Unit 13 - Iterators
 - Why we use them?
 - General implementation approach (operator overloading, saving some internal state to track which item is being referenced, etc.)

#### Unit 14 - BSTs and Balanced (AVL) Binary Search Trees
 - Binary search tree property
 - BST operations: find, insert, remove and their runtimes
 - AVL tree property (using height or balance values)
 - AVL operations: insert and remove (be able to perform these yourself on paper) but you do not need to memorize the pseudocode

#### Unit 15 - Splay trees
 - Runtime properties
 - How to splay an element to the top
 - How insert, find, and remove work

#### Unit 17 - Counting
 - All relevant counting rules and approaches taught in lecture and on HW

#### Unit 18 - Probability
 - All relevant counting rules and approaches taught in lecture and on HW
 - Basic probability calculation
 - Conditional probability and its definition
 - Law of total probability
 - Definition of (mutual and pairwise) independence
 - Bernoulli trials and binomial distribution
 - Bayes Theorem
 - Random Variables and Expected Value
 - Linearity of Expectation
 - Geometric Distribution

#### Unit 19 - Number Theory
 - Definitions of modular congruence
 - Performing modular arithmetic
 - Modular exponentiation techniques
 - Euclid's algorithm for finding `gcd`
 - Finding multiplicative inverses for modulo-n systems
 - Solving Diophantine equations

#### Unit 20 - Hash Tables, Functions, and Bloom Filters
 - Properties of hash functions
 - Dealing with collisions
  - Closed addressing: chaining or buckets
  - Open addressing: probing (linear, quadratic, double-hashing)
 - Runtime and relationship to loading factor
 - One-way / cryptographic hash functions
 - Bloom filter pros and cons
 - Bloom filter operations (insert and find)

#### Unit 22 - Prefix Trees and Compressed Prefix Trees
 - Construction and insertion
 - Finding elements
 - Ways of structure nodes (arrays vs. linked lists for sparse implementations)
 - Compressed prefix trees

#### Unit 23-24 - Amortized Analysis and Merge Trees
 - Approaches to performing amortized analysis
 - General structure of a merge tree


### Practice Materials

#### Sample Finals

 - [Sample Final (Spring 2014)]({{site.baseurl}}/resources/final-a.pdf) (no solutions)
 - [Sample Final (Spring 2014 and others)]({{site.baseurl}}/resources/final-b.pdf) (no solutions)

 - [Final Practice (Summer 2020)]({{site.baseurl}}/resources/cs104-su20-final-prac.pdf) 
 - [Final Practice Solutions (Summer 2020)]({{site.baseurl}}/resources/cs104-su20-final-prac-sol.pdf)
